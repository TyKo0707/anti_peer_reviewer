// POC contract
// TODO: 
// - Split down into smaller contracts

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol";

interface IVRFCoordinatorV2 {
    function requestRandomWords(
        bytes32 keyHash, uint64 subId,
        uint16 minConf, uint32 gasLimit,
        uint32 numWords
    ) external returns (uint256 requestId);
}

contract PaperReview is VRFConsumerBaseV2, ERC20, ERC721 {

    /*//////////////////////////////////////////////////////////////
                               CONFIG
    //////////////////////////////////////////////////////////////*/
    struct Reviewer { uint64 stake; uint64 rep; }
    struct Paper {
        string cid; address author; uint8 score; bool settled;
        uint256[] reviewers; uint256 deadline; mapping(uint256 => bytes32) voteHash;
    }

    uint256 public constant MIN_STAKE = 1_000 ether;
    uint256 public constant POS_THRESHOLD = 3;
    uint64  public immutable subId;
    bytes32 public immutable keyHash;
    IVRFCoordinatorV2 public immutable vrf;
    uint256 public nextPaperId;
    uint256 public nextNftId;
    uint32  public revealPeriod = 3 days;

    mapping(address => Reviewer) public reviewers;
    mapping(uint256 => Paper) public papers;

    /*//////////////////////////////////////////////////////////////
                             CONSTRUCTOR
    //////////////////////////////////////////////////////////////*/
    constructor(
        address _vrfCoord, bytes32 _keyHash, uint64 _subId
    )
        ERC20("Peer-Review Token", "PROOF")
        ERC721("Peer-Review DOI",  "DOI")
        VRFConsumerBaseV2(_vrfCoord)
    {
        vrf     = IVRFCoordinatorV2(_vrfCoord);
        keyHash = _keyHash;
        subId   = _subId;
        _mint(msg.sender, 1_000_000 ether);           // faucet for PoC
    }

    /*//////////////////////////////////////////////////////////////
                           REVIEWER LIFECYCLE
    //////////////////////////////////////////////////////////////*/
    function stake() external {
        _transfer(msg.sender, address(this), MIN_STAKE);
        reviewers[msg.sender].stake += uint64(MIN_STAKE);
        reviewers[msg.sender].rep   = 50;              // neutral
    }

    /*//////////////////////////////////////////////////////////////
                               AUTHOR SIDE
    //////////////////////////////////////////////////////////////*/
    function submitPaper(string calldata cid) external payable {
        require(msg.value == 0.01 ether, "fee 0.01 ETH");
        uint256 id = nextPaperId++;
        Paper storage p = papers[id];
        p.cid    = cid;
        p.author = msg.sender;
        // ask VRF for 3 reviewers
        vrf.requestRandomWords(keyHash, subId, 3, 150_000, 1);
    }

    /*//////////////////////////////////////////////////////////////
                        VRF CALLBACK → select reviewers
    //////////////////////////////////////////////////////////////*/
    mapping(uint256 => uint256) vrfToPaper;
    function fulfillRandomWords(
        uint256 reqId, uint256[] memory rand
    ) internal override {
        uint256 paperId = vrfToPaper[reqId];
        Paper storage p = papers[paperId];
        require(p.reviewers.length == 0, "already");
        address[] memory pool = _eligiblePool();
        for (uint256 i; i < 3 && i < pool.length; ++i) {
            uint256 idx = uint256(
                keccak256(abi.encode(rand[0], i))
            ) % pool.length;
            p.reviewers.push(uint160(pool[idx]));
        }
        p.deadline = block.timestamp + revealPeriod;
    }

    function _eligiblePool() internal view returns (address[] memory pool) {
        uint256 len; // count first
        for (uint256 i; i < 100; ++i) { } // PoC: pretend list in storage
    }

    /*//////////////////////////////////////////////////////////////
                         COMMIT / REVEAL VOTING
    //////////////////////////////////////////////////////////////*/
    function commitVote(
        uint256 paperId, bytes32 hash
    ) external {
        uint256 idx = _reviewerIndex(paperId, msg.sender);
        Paper storage p = papers[paperId];
        require(block.timestamp < p.deadline, "late");
        p.voteHash[idx] = hash;
    }

    function revealVote(
        uint256 paperId, int8 score, string calldata comment
    ) external {
        uint256 idx = _reviewerIndex(paperId, msg.sender);
        Paper storage p = papers[paperId];
        require(block.timestamp < p.deadline + 1 days, "too late");
        require(
            p.voteHash[idx] == keccak256(abi.encode(score, comment)),
            "hash mismatch"
        );
        p.score += uint8(int8(p.score) + score); // –2 … +2
        // reputations
        if (score > 0) reviewers[msg.sender].rep += 1;
        else reviewers[msg.sender].rep -= 1;
    }

    function settle(uint256 paperId) external {
        Paper storage p = papers[paperId];
        require(!p.settled && block.timestamp > p.deadline + 1 days, "wait");
        p.settled = true;

        if (p.score >= POS_THRESHOLD) {
            // mint DOI NFT
            _safeMint(p.author, nextNftId++);
            // simple reward
            _transfer(address(this), msg.sender, 10 ether);
        } else {
            // partial refund logic here (skipped PoC)
        }
    }

    /*//////////////////////////////////////////////////////////////
                               HELPERS
    //////////////////////////////////////////////////////////////*/
    function _reviewerIndex(uint256 paperId, address r)
        internal view returns (uint256 idx)
    {
        Paper storage p = papers[paperId];
        for (uint256 i; i < p.reviewers.length; ++i)
            if (address(uint160(p.reviewers[i])) == r) return i;
        revert("not reviewer");
    }
}

